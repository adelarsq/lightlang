# Syntax (WIP)

This document specify the core syntax rules for the language.

## General Rules

- no inheritance - this is made with composition (Rusty like)
- named parameters (based on OCalm [link](https://v2.ocaml.org/manual/lablexamples.html))

## Comments

Simple comments (ELM):

```light
-- Comments are markdown by default
```

Multiline comments ([ELM](https://elmprogramming.com/comment.html#multi-line-comments)):

```light
{- a multiline comment based on ELM
   {- can be nested -}
-}
```

Typed comments (Light):

```light
{-xml The `let` keyword defines an (immutable) value xml-}
{-sql select * from table sql-}
{-md select * from table md-}
```

[Type annotations](https://coffeescript.org/#comments) (CoffeeScript):

```
# This comment will be transpiled together
```

## Types

```
i8 i16 i32 i64 i128 i256 -- i integers (Zig)
u8 u16 u32 u64 u128 u256 -- u unsigned integers (Zig)
f32 f64 -- float numbers (Zig)
f32.31 -- signed float number with 32 bits and 31 bits for mantissa -- TODO How many bits mantissa can use? (Light)
f64.32 -- signed float number with 64 bits and 32 bits for mantissa (Light)
uf32.31 -- unsigned float number with 32 bits and 31 bits for mantissa (Light)
uf64.32 -- unsigned float number with 64 bits and 32 bits for mantissa (Light)
c8 c16 -- c chars -- TODO
s8 s16 -- s strings -- TODO
b1 b8  -- b boolean -- TODO Do booleans always have 8 bits?
:a :b  -- atoms (Elixir, LISP)
```

Rust: [*](https://doc.rust-lang.org/book/ch03-02-data-types.html)
Zig: [*](https://ziglang.org/documentation/master/#toc-Runtime-Integer-Values)

## Values

```
"hello"           -- or ["hello"] one string value
["hello" "world"] -- two string values
3.14              -- or [3.14] one float value
[3.14 4.15]       -- two float values (tuple)
[3.14 4.15 5.15]  -- three float values (tuple)
date 2023 12 3 -- dates are always in the order year, month, day
```

## Operators (C based)

Aritmetic:

- `+`
- `-`
- `/`
- `*`
- `%`

Logical:

- `&&`
- `||`
- `!`

Binaries:

- `&`
- `|`
- `^`
- `>>`
- `<<`
- `>>>`

## Functions

```light
-- Closures are defined with -> 
fn x y -> x + y

-- Functions are defined with =>
fn sum x y =>
    x + y

-- Infered return type
fn sum x:i32 y:i32 => i32
    x + y

-- Typed return type
fn sum x:i32 y:i32 => i32
    x + y
   
-- Multiple return types (confirm)
fn sumOrSub x:i32 y:i32 => i32 i32
    x + y
    x - y
   
-- Defining new operators -- TODO
fn * x y =>
    100
    
-- Defining function names as strings
-- ? defines a test
fn "returns a sum" ?
   let s = sum 10 20
   assert = 30 s
```

Default values:

```
fn sum x:i32=10 y:i32 : i32 =>
    x + y

fn array2list list:Array[i32]=[10,10,10] : List[i32] =>
    ...
```

## Generics

```light
// Closures are defined with -> 
fn x y -> x + y
fn x:a y:a :a-> x + y

-- Functions are defined with =>
fn sum x y =>
    x + y
fn sum x:a y:a :a=>
    x + y

fn sum x:i32 y:i32 :i32=>
    x + y
   
-- Defining new operators -- TODO
fn * x y =>
    100
fn * x:a y:a :a=>
    100
```

## Another Types

```light
-- Generic record, with the type parameter in angle brackets
type MyRecord:a =
     Field1:a
     Field2:a

-- Generic discriminated union
type MyUnion:a =
    | Choice1:a
    | Choice2:a*a

-- Tuple
Tuple [1 2]
```

## Collections

### Array

A raw array that can be acessed by an integer index

```
Array [1 3 4 5]
```

### List

A linked list:

```
List [1 3 4 5]
```

### Sequence

Itens are generated by demand:

```
Seq [1 2 3 4]
```

## Flux Control

### Conditionals

#### if

```
if a > 11 then "> 11" else "<= 11"
```

[1](https://elmprogramming.com/if-expression.html)

#### case

```
case maybeList
  Just xs -> xs
  Nothing -> []

case xs
  [] ->
    Nothing
  first :: rest ->
    Just (first, rest)

case n
  0 -> 1
  1 -> 1
  _ -> fib (n-1) + fib (n-2)
```

### Loops

#### for

#### while

#### do

## Low Level

### Pointers and References

```
let a = 1
let pointer = ^a
let reference = a^
```

[1](https://odin-lang.org/docs/overview/#pointers)

## Core Library

### Default functions

- `try` - same as `try` from Zig [link](https://ziglang.org/documentation/master/#try)
- `map`
- `reduce`

